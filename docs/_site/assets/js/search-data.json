{"0": {
    "doc": "Base quantity",
    "title": "Base quantity",
    "content": "The base_quantity struct represents a physical quantity by storing the powers of the seven base quantities of the International System of Units (SI) - length, time, mass, temperature, electric_current, substance_amount, and luminous_intensity, as template parameters: . template &lt;int LENGTH, int TIME, int MASS, int TEMPERATURE, int ELETTRIC_CURRENT, int SUBSTANCE_AMOUNT, int LUMINOUS_INTENSITY&gt; struct base_quantity { static constexpr std::array&lt;int, 7&gt; powers = {LENGTH, TIME, MASS, TEMPERATURE, ELETTRIC_CURRENT, SUBSTANCE_AMOUNT, LUMINOUS_INTENSITY}; ///&lt; array of the powers of the base quantities static constexpr std::array&lt;std::string_view, 7&gt; base_literals = {\"m\", \"s\", \"kg\", \"K\", \"A\", \"mol\", \"cd\"}; //&lt; array of the literals of the base quantities /// @brief Returns the string representation of the base_quantity static constexpr std::string_view to_string() noexcept { std::stringstream ss; // Iterate over the base quantities and their powers meta::for_&lt;7&gt;([&amp;](auto i) constexpr { if constexpr (powers[i] != 0) { if constexpr (powers[i] == 1) // Append the base quantity to the string builder ss &lt;&lt; base_literals[i]; else // Append the base quantity and its power to the string builder ss &lt;&lt; base_literals[i] &lt;&lt; '^' &lt;&lt; powers[i]; } }); return ss.str(); } }; . The powers of the base quantities can be accessed using the corresponding aliases. It is possible to define custom base_quantities using the constuctor providing the powers, or just by combining existing types using the basic operations, defined inside the scipp::math::op namespace, such as multiplication, division, and exponentiation. The base quantities are not meant to be used directly, but rather as template parameters for the unit and measurement structs. The principal base quantities are defined in the scipp::physics::base namespace: . namespace base { using length = base_quantity&lt;1, 0, 0, 0, 0, 0, 0&gt;; ///&lt; metre base_quantity using time = base_quantity&lt;0, 1, 0, 0, 0, 0, 0&gt;; ///&lt; second base_quantity using mass = base_quantity&lt;0, 0, 1, 0, 0, 0, 0&gt;; ///&lt; kilogram base_quantity using temperature = base_quantity&lt;0, 0, 0, 1, 0, 0, 0&gt;; ///&lt; kelvin base_quantity using electric_current = base_quantity&lt;0, 0, 0, 0, 1, 0, 0&gt;; ///&lt; ampere base_quantity using substance_amount = base_quantity&lt;0, 0, 0, 0, 0, 1, 0&gt;; ///&lt; mole base_quantity using luminous_intensity = base_quantity&lt;0, 0, 0, 0, 0, 0, 1&gt;; ///&lt; candela base_quantity using angle = math::op::divide_t&lt;length, length&gt;; ///&lt; radian base_quantity using area = math::op::multiply_t&lt;length, length&gt;; ///&lt; square_metre base_quantity using volume = math::op::multiply_t&lt;length, area&gt;; ///&lt; cubic_metre base_quantity using velocity = math::op::divide_t&lt;length, time&gt;; ///&lt; metre_per_second base_quantity using acceleration = math::op::divide_t&lt;velocity, time&gt;; ///&lt; metre_per_second_squared base_quantity using angular_velocity = math::op::divide_t&lt;angle, time&gt;; ///&lt; radian_per_second base_quantity using angular_acceleration = math::op::divide_t&lt;angular_velocity, time&gt;; ///&lt; radian_per_second2 base_quantity using momentum = math::op::multiply_t&lt;mass, velocity&gt;; ///&lt; kilogram_metre_per_second base_quantity using impulse = math::op::multiply_t&lt;momentum, time&gt;; ///&lt; kilogram_metre_per_second base_quantity using angular_momentum = math::op::multiply_t&lt;momentum, length&gt;; ///&lt; kilogram_metre_squared_per_second base_quantity using force = math::op::multiply_t&lt;mass, acceleration&gt;; ///&lt; newton base_quantity using torque = math::op::multiply_t&lt;force, length&gt;; ///&lt; newton_metre base_quantity using energy = math::op::multiply_t&lt;force, length&gt;; ///&lt; joule base_quantity using action = math::op::multiply_t&lt;energy, time&gt;; ///&lt; joule_second base_quantity using power = math::op::divide_t&lt;energy, time&gt;; ///&lt; watt base_quantity using pressure = math::op::divide_t&lt;force, area&gt;; ///&lt; pascal base_quantity using density = math::op::divide_t&lt;mass, volume&gt;; ///&lt; kilogram_per_cubic_metre base_quantity using frequency = math::op::invert_t&lt;time&gt;; ///&lt; hertz base_quantity [...] } . ",
    "url": "/base_quantity",
    
    "relUrl": "/base_quantity"
  },"1": {
    "doc": "Units and measurements",
    "title": "Units and measurements",
    "content": "Usage . Creating measurements . In the following example we show how to create measurements and how to use them. // Creating measurements with explicit value_type and base_quantity measurement&lt;basis::length, int&gt; l0(1, units::m); print(sizeof(l0)); ///&lt; '4' (bytes) // Creating measurements by multiplying a number by a unit measurement&lt;basis::length&gt; l1 = 2.0 * units::m; // @note the value_type is deduced from the number // @note the unit base_quantity must be compatible with the base_quantity of the measurement print(sizeof(l1)); ///&lt; '8' (bytes) // Creating measurements with implicit deduction of base quantity and value type measurement l2 = 3.0 * units::m; print(l2); ///&lt; '3.0 m' // Creating measurements with a prefixed unit auto l3 = 4.0 * units::cm; print(l3); ///&lt; '0.04 m' // @note The prefix is automatically applied to the value by multiplying it by the prefix factor // Printing a measurement with a specific unit type print&lt;units::centimetre&gt;(l3); ///&lt; '4.0 [c]m' print(l3, units::cm); ///&lt; '4.0 [c]m' // @note the unit base_quantity must be compatible with the base_quantity of the measurement // Using literal operators for units using namespace units::literals; auto l4 = 5.0m; auto l5 = 6.0mm; print(l4); ///&lt; '5.0 m' print(l5); ///&lt; '0.006 m' // Creating measurements by combining other measurements auto l6 = l1 + l2; print(l6); ///&lt; '5.0 m' print(l1 * l2); ///&lt; '6 m^2' print(\"l1 / l2 = \", l1 / l2); ///&lt; 'l1 / l2 = 0.666667' print&lt;std::centi&gt;(\"l1 / l2 = \", l1 / l2); ///&lt; 'l1 / l2 = 0.67' print&lt;std::milli&gt;(\"l1 / l2 = \", l1 / l2); ///&lt; 'l1 / l2 = 0.667' . A more concrete example . Consider an example, a little more complex, in which we want to plot the intensity of the diffraction pattern generated by a light beam, passing through a slit on a screen at a fixed distance, given by the integral function: . \\[I (x) = \\int _{-\\frac{d}{2}} ^{\\frac{d}{2}} dx' cos(\\frac{2\\pi}{\\lambda} \\cdot (\\sqrt{L^2 + (x - x')^2} - \\sqrt{L^2 + x^2}))\\] where $d$ is the slit width, $\\lambda$ is the wavelength of the light and $x$ is the distance from the center of the screen. We can write the code in this way: . #include \"scipp\" using namespace scipp; using namespace physics; // for measurements using namespace units; // for the units using namespace units::literals; // for the units literals using namespace math; using namespace op; // for the operators and the functions using namespace calculus; // for the integral function and the interval struct using tools::print; // for the print function int main() { /// parameters of the experiment constexpr auto d = 10.0um; /// slit width constexpr auto lambda = 589.0nm; /// wavelength constexpr auto L = 0.5m; /// distance from the slit to the screen constexpr auto I_int = interval(-0.5 * d, 0.5 * d); /// interval of integration measurement&lt;basis::length&gt; x = -0.2m; /// variable for the function I(x) constexpr auto I = interval(-0.2m, 0.2m); /// interval of points where we want to evaluate I(x) constexpr auto dx = 1.0mm; /// distance between two points constexpr size_t N = I.steps(dx); /// numer of points with the math::calculus::interval function /// we define the integral function of I(x) as an std::function /// we use a lambda function and we pass by value the parameters and by reference the integral variable /// the function is a scalar function, so it returns a measurement with basis::scalar std::function f = [lambda, L, &amp;x](measurement&lt;basis::length&gt; t) -&gt; measurement&lt;basis::scalar&gt; { constexpr auto k = 2.0 * std::numbers::pi / lambda; /// wave number return cos(k * (hypot(L, x - t) - hypot(L, x))); /// using the math::op::hypot function }; print&lt;micrometre&gt;(\"d = \", d); /// we can specify the unit of measurement as a template parameter (type) print(\"lambda = \", lambda, nm); /// or we can specify the unit of measurement as a function parameter (value) print(\"interval of integration: \", I_int); /// we can print the interval too print(\"f(0.0m) = \", f(0.0m)); /// we can evaluate the function at a point std::vector&lt;double&gt; integral_values(N), x_values(N); /// to store the values for the plot /// we iterate over the interval using the meta::for_ function meta::for_&lt;N&gt;([&amp;](auto i) { /// we store the value of x, not the measurement x_values[i] = x.value; /// we evaluate the integral using i.e. the midpoint rule from the math::calculus namespace /// the result of the integral is the width of the diffraction pattern /// the integration is correct from a dimensional point of view: the result is a measurement with basis::length /// the precision of the calculation could be specified using an std::ratio as a template parameter /// you can also just fix a number of steps as a function parameter or template parameter, as you prefer integral_values[i] = midpoint&lt;std::micro&gt;(f, I_int).value_as(um); /// we extract the value of the integral in micrometres /// we increment the x variable by dx x += dx; }); /// we plot the results using the matplotlib-cpp library plt::figure(); plt::title(\"Diffracted intensity\"); plt::plot(x_values, integral_values); plt::xlabel(\"x [m]\"); // we can specify the unit of measurement plt::ylabel(\"I [um]\"); // we can specify the unit of measurement plt::grid(true); plt::tight_layout(); plt::save(\"images/diffracted_intensity.png\"); plt::show(); return 0; } . Here is the output of the program: . d = 10 [u]m lambda = 589 m interval of integration: [ -5e-06 m, 5e-06 m ] f(0.0m) = 1 . Benchmarks . The benchmarks are performed using the Google Benchmark library and can be found in the benchmark folder from the root of the repository. Here are the results of the benchmarks of the scipp::math::op functions on double and measurement, in comparison with the standard operators built-in in the C++ language: ``` bash Run on (8 X 3400 MHz CPU s) CPU Caches: L1 Data 32 KiB (x4) L1 Instruction 32 KiB (x4) L2 Unified 256 KiB (x4) L3 Unified 6144 KiB (x1) Load Average: 0.74, 0.97, 1.12 . ",
    "url": "/physics/units-and-measurements/",
    
    "relUrl": "/physics/units-and-measurements/"
  },"2": {
    "doc": "Units and measurements",
    "title": "Running ./build/benchmark/op/double",
    "content": "Benchmark Time CPU Iterations —————————————————— BM_Add 0.628 ns 0.628 ns 1000000000 BM_Multiply 0.628 ns 0.628 ns 1000000000 BM_Invert 0.628 ns 0.628 ns 1000000000 BM_Square 0.628 ns 0.628 ns 1000000000 . ",
    "url": "/physics/units-and-measurements/#running-buildbenchmarkopdouble",
    
    "relUrl": "/physics/units-and-measurements/#running-buildbenchmarkopdouble"
  },"3": {
    "doc": "Units and measurements",
    "title": "Running ./build/benchmark/op/measurement",
    "content": "Benchmark Time CPU Iterations —————————————————— BM_Add 0.629 ns 0.629 ns 1000000000 BM_Multiply 0.629 ns 0.629 ns 1000000000 BM_Invert 0.628 ns 0.628 ns 1000000000 BM_Square 0.628 ns 0.628 ns 1000000000 . ",
    "url": "/physics/units-and-measurements/#running-buildbenchmarkopmeasurement",
    
    "relUrl": "/physics/units-and-measurements/#running-buildbenchmarkopmeasurement"
  },"4": {
    "doc": "Units and measurements",
    "title": "Running ./build/benchmark/op/built_in",
    "content": "Benchmark Time CPU Iterations —————————————————— BM_Add 0.629 ns 0.629 ns 1000000000 BM_Multiply 0.629 ns 0.629 ns 1000000000 BM_Invert 0.629 ns 0.629 ns 1000000000 BM_Square 0.635 ns 0.635 ns 1000000000 . ",
    "url": "/physics/units-and-measurements/#running-buildbenchmarkopbuilt_in",
    
    "relUrl": "/physics/units-and-measurements/#running-buildbenchmarkopbuilt_in"
  },"5": {
    "doc": "Home",
    "title": "Compile Time Dimensional Analysis in C++",
    "content": "Dimensional analysis plays a crucial role in scientific computations by ensuring that mathematical expressions and equations are consistent in terms of units and dimensions. The library incorporates a compile-time structure for dimensional analysis, allowing users to define and manipulate physical quantities with their associated units. ",
    "url": "/#compile-time-dimensional-analysis-in-c",
    
    "relUrl": "/#compile-time-dimensional-analysis-in-c"
  },"6": {
    "doc": "Home",
    "title": "Usage",
    "content": "The library provides a quantity class template that can be used to define physical quantities with their associated units. The quantity class template is defined as follows: . template &lt;typename value_t, typename unit_t&gt; class quantity; . The value_t template parameter is used to define the type of the value of the quantity, while the unit_t template parameter is used to define the type of the unit of the quantity. The unit_t template parameter must be a type that satisfies the unit concept. The unit struct represents a unit of measurement by combining a base_quantity with an std::ratio prefix: . template &lt;typename base_t, typename prefix_t = std::ratio&lt;1&gt;&gt; class unit { static constexpr auto factor = static_cast&lt;double&gt;(prefix_t::num) / static_cast&lt;double&gt;(prefix_t::den); ///&lt; conversion factor of the unit } . The base_t template parameter is used to define the type of the base unit of the unit, while the prefix_t template parameter is used to define the type of the prefix of the unit. In the units namespace are defined the most common units of measure. The base_quantity struct represents a physical quantity by storing the powers of the seven base quantities of the International System of Units (SI) - length, time, mass, temperature, electric_current, substance_amount, and luminous_intensity, as template parameters: . template &lt;int LENGTH, int TIME, int MASS, int TEMPERATURE, int ELETTRIC_CURRENT, int SUBSTANCE_AMOUNT, int LUMINOUS_INTENSITY&gt; struct base_quantity { static constexpr std::array&lt;int, 7&gt; powers = {LENGTH, TIME, MASS, TEMPERATURE, ELETTRIC_CURRENT, SUBSTANCE_AMOUNT, LUMINOUS_INTENSITY}; ///&lt; array of the powers of the base quantities }; . ",
    "url": "/#usage",
    
    "relUrl": "/#usage"
  },"7": {
    "doc": "Home",
    "title": "How to install",
    "content": "You can clone the repository using this command: . git clone https://github.com/lorenzoliuzzo/ctda.git . You can easily use the library by including the header file in your code: . #include \"ctda.hpp\" using namespace ctda; . If you want to use the library in your project, you can add the following line to your CMakeLists.txt file: . target_include_directories(${PROJECT_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/path/to/ctda) . If you would want to run the tests and the examples, you can use the following commands from the root directory of the repository: . bash build.sh . After that, you can run the tests and the examples using the following commands: ./build/tests/some_test ./build/examples/some_example . ",
    "url": "/#how-to-install",
    
    "relUrl": "/#how-to-install"
  },"8": {
    "doc": "Home",
    "title": "Contributing",
    "content": "If you want to contribute to the project, you can open a pull requests or use the issue tracker to suggest any code implementations or report bugs. Any contributions are welcome! . ",
    "url": "/#contributing",
    
    "relUrl": "/#contributing"
  },"9": {
    "doc": "Home",
    "title": "License",
    "content": "The code is released under the terms of the GNU General Public License v3.0, see the LICENSE. ",
    "url": "/#license",
    
    "relUrl": "/#license"
  },"10": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"11": {
    "doc": "Quantity",
    "title": "Measurement",
    "content": "Most of the time we write code to solve a problem that has a physical meaning, we assume that the code that we write is physically correct, but often we do make mistakes or, simply, we do not fully understand the problem we are trying to solve yet. ",
    "url": "/quantity#measurement",
    
    "relUrl": "/quantity#measurement"
  },"12": {
    "doc": "Quantity",
    "title": "A simple example",
    "content": "Consider this basic example, where we want to do something physically meaningful, like calculating the force upon an object. Suppose an apple fell from a tree and hit your head so hard that you can not remember Newton’s second law of motion. You decide to calculate the force using whatever physical quantity presents itself to you. You measure the length of the tree and the mass of the apple and use them to calculate the force in this way: . double calculate_force(double mass, double length) { return mass + length; } int main() { // This code will compile because it's not wrong to add any generic numbers double length{2.5}; double mass{3.0}; double force = calculate_force(length, mass); return 0; } . The code compiles, but it would give you a wrong anwser, because of the wrong physics law you choose to invent to calculate the force. This is due to the fact that the compiler does not know the physical meaning of the code, it only knows the type of the variables, which is not enough to understand the physical meaning of the code. To find these types of error, if we are lucky enough to notice some weird numerical results, we need to read the code and understand the physical meaning of the code, which is not always easy. As long as the compiler can not distinguish between numbers used to represents different physical quantities, it does not help us in any way and we are left with a mad search through the code. The solution is to use a type that encodes the physical meaning of the variable as well as its value type. The scipp library comes in handy here. The measurement struct represents a physical measurement as a value with a dimensional-aware template meta-structure. Using the measurement struct, it is possible to perform dimensional analysis at compile-time without loss of precision and overhead. Basically, writing physical accurate code is now possible and easy! . template &lt;typename BASE_T, typename VALUE_TYPE = double&gt; requires (is_base_v&lt;BASE_TYPE&gt; &amp;&amp; math::is_number_v&lt;VALUE_TYPE&gt;) struct measurement { using base_t = BASE_TYPE; ///&lt; The base of the measurement using value_t = VALUE_TYPE; ///&lt; The type of the value of the measurement value_t value; ///&lt; The value of the measurement static constexpr measurement zero{value_t{}}; ///&lt; The zero measurement static constexpr measurement one{value_t{1.0}}; ///&lt; The one measurement /// @brief Default constructor constexpr measurement() noexcept : value{value_t{}} {} /// @brief Construct a measurement from a scalar value constexpr measurement(const value_t&amp; val) noexcept : value{val} {} /// @brief Construct a measurement from a scalar value constexpr measurement(value_t&amp;&amp; val) noexcept : value{std::move(val)} {} /// @brief Construct a measurement from a scalar value and an unit /// @note The unit must be of the same base of the measurement /// @note The value is immediatly converted to the base unit template &lt;typename UNIT_TYPE&gt; requires (is_unit_v&lt;UNIT_TYPE&gt; &amp;&amp; is_same_base_v&lt;base_t, typename UNIT_TYPE::base_t&gt;) constexpr measurement(value_t&amp;&amp; val, const UNIT_TYPE&amp;) noexcept { using prefix_t = typename UNIT_TYPE::prefix_t; constexpr auto factor = static_cast&lt;double&gt;(prefix_t::num) / static_cast&lt;double&gt;(prefix_t::den); this-&gt;value = std::forward&lt;value_t&gt;(val * factor); } /// @brief Implicitly convert the measurement to a scalar value if it is a scalar base measurement constexpr operator value_t() const requires is_scalar_base_v&lt;base_t&gt; { return this-&gt;value; } /// @brief Extract the value of this measurement converted to a specific unit /// @note The unit must be of the same base of the measurement template &lt;typename T&gt; constexpr auto value_as(const unit&lt;base_t, T&gt;&amp;) const noexcept { return this-&gt;value / static_cast&lt;double&gt;(T::num) * static_cast&lt;double&gt;(T::den); } /// @brief Print a measurement to an output stream friend constexpr std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const measurement&amp; other) noexcept { os &lt;&lt; other.value; if constexpr (!is_scalar_base_v&lt;base_t&gt;) os &lt;&lt; ' ' &lt;&lt; base_t::to_string(); return os; } }; . The value type is defaulted to double, but it can be changed to any type that supports the basic arithmetic operations. Operations between measurements with different units are allowed and they respect the dimensional analysis rules, i.e. we cannot sum two measurements with different base units, but we can multiply them to product something with a different physical meaning. For example, we can write the previous code in this way: . int main() { measurement&lt;basis::length, double&gt; length{1.0}; measurement&lt;basis::mass, double&gt; mass{60.0}; measurement&lt;basis::force, double&gt; force{length * mass}; } . This code will not compile yet because it contains incorrect physical operations, but at least the physical error in the code is now clear to the compiler, which will give us an error message that will help us understand the problem: . error: conversion from ‘measurement&lt;base_quantity&lt;[...],0,[...],[...],[...],[...],[...]&gt;,[...]&gt;’ to non-scalar type ‘measurement&lt;base_quantity&lt;[...],-2,[...],[...],[...],[...],[...]&gt;,[...]&gt;’ requested here: measurement&lt;basis::force, double&gt; force = length * mass; . We are indeed trying to assign a value obtained from the multiplication of a length and a mass, which does not correspond to the physical meaning of the force, to a variable of type measurement&lt;basis::force, double&gt;. Remembering Newton second law, we can rewrite the previous code in the correct way: . int main() { measurement&lt;basis::acceleration, double&gt; a{1.0}; measurement&lt;basis::mass, double&gt; m{60.0}; measurement&lt;basis::force, double&gt; F = m * a; } . Maybe you are thinking that this is all very nice, but that it is not worth the effort to write code in this way, because it is too complicated, but simply this is not true. In fact, the code is not more complicated, it is just different. Please note that this is all done at compile time, so we don’t have to run the code and maybe, if we are lucky, find a little suspicius numerical result that will make us think that something is wrong in the code and then manually debug it to find the error. The compiler will tell us exactly where the error is and what the error is, so we can fix it immediately and return to code. Another advantage of using the measurement struct is that we can do not bother about conversions between units, instead we can just write our physical code in a natural way, as we would do on paper. ",
    "url": "/quantity#a-simple-example",
    
    "relUrl": "/quantity#a-simple-example"
  },"13": {
    "doc": "Quantity",
    "title": "Quantity",
    "content": " ",
    "url": "/quantity",
    
    "relUrl": "/quantity"
  },"14": {
    "doc": "Unit",
    "title": "Unit",
    "content": "The unit struct represents a unit of measurement by combining a base_quantity with an std::ratio prefix: . template &lt;typename BASE_T, typename PREFIX_T = std::ratio&lt;1&gt;&gt; requires (is_base_v&lt;BASE_T&gt; &amp;&amp; is_prefix_v&lt;PREFIX_T&gt;) struct unit { using base_t = BASE_T; ///&lt; base_quantity type using prefix_t = PREFIX_T; ///&lt; prefix type /// @brief Return a string representation of the unit static constexpr std::string to_string() noexcept { std::stringstream ss; auto factor = static_cast&lt;double&gt;(prefix_t::num) / static_cast&lt;double&gt;(prefix_t::den); constexpr auto prefix = std::lower_bound(prefix_map.begin(), prefix_map.end(), factor, [](const auto&amp; p, const auto&amp; value) { return p.first &lt; value; }); if constexpr (prefix == prefix_map.end()) ss &lt;&lt; base_t::to_string(); else ss &lt;&lt; \"[\" &lt;&lt; prefix-&gt;second &lt;&lt; \"]\" &lt;&lt; base_t::to_string(); return ss.str(); } }; . In the units namespace are defined the most common units of measure: . namespace units { using metre = unit&lt;basis::length, std::ratio&lt;1&gt;&gt;; ///&lt; metre unit inline static constexpr metre m; ///&lt; m unit using kilometre = unit&lt;basis::length, std::kilo&gt;; ///&lt; kilometre unit inline static constexpr kilometre km; ///&lt; Km unit using decimetre = unit&lt;basis::length, std::deci&gt;; ///&lt; decimetre unit inline static constexpr decimetre dm; ///&lt; dm unit using centimetre = unit&lt;basis::length, std::centi&gt;; ///&lt; centimetre unit inline static constexpr centimetre cm; ///&lt; cm unit [...] using second = unit&lt;basis::time, std::ratio&lt;1&gt;&gt;; ///&lt; second unit inline static constexpr second s; ///&lt; s unit using minute = unit&lt;basis::time, std::ratio&lt;60&gt;&gt;; ///&lt; minute unit inline static constexpr minute min; ///&lt; min unit using hour = unit&lt;basis::time, std::ratio&lt;3600&gt;&gt;; ///&lt; hour unit inline static constexpr hour h; ///&lt; h unit [...] using kilogram = unit&lt;basis::mass&gt;; ///&lt; kilogram unit inline static constexpr kilogram kg; ///&lt; kg unit using gram = unit&lt;basis::mass, std::milli&gt;; ///&lt; gram unit inline static constexpr gram g; ///&lt; g unit [...] using litre = cubic_decimetre; ///&lt; litre unit inline static constexpr litre L; ///&lt; L unit using joule = unit&lt;basis::energy&gt;; ///&lt; Joule unit inline static constexpr joule J; ///&lt; J unit using newton = unit&lt;basis::force&gt;; ///&lt; Newton unit inline static constexpr newton N; ///&lt; N unit using pascal = unit&lt;basis::pressure&gt;; ///&lt; Pascal unit inline static constexpr pascal Pa; ///&lt; Pa unit [...] } . ",
    "url": "/unit",
    
    "relUrl": "/unit"
  }
}
