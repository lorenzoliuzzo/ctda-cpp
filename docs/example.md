---
title: Units and measurements
layout: default
permalink: /physics/units-and-measurements/
parent: Physics namespace
author_profile: true
---

# Units and measurements



### Usage

#### Creating measurements
In the following example we show how to create measurements and how to use them.
```cpp
    // Creating measurements with explicit value_type and base_quantity
    measurement<basis::length, int> l0(1, units::m);     

    print(sizeof(l0));                                  ///< '4' (bytes)

    // Creating measurements by multiplying a number by a unit 
    measurement<basis::length> l1 = 2.0 * units::m;      
    // @note the value_type is deduced from the number
    // @note the unit base_quantity must be compatible with the base_quantity of the measurement

    print(sizeof(l1));                                  ///< '8' (bytes)

    // Creating measurements with implicit deduction of base quantity and value type
    measurement l2 = 3.0 * units::m;    
    print(l2);                                          ///< '3.0 m'

    // Creating measurements with a prefixed unit
    auto l3 = 4.0 * units::cm;                          
    
    print(l3);                                          ///< '0.04 m'
    // @note The prefix is automatically applied to the value by multiplying it by the prefix factor

    // Printing a measurement with a specific unit type
    print<units::centimetre>(l3);                       ///< '4.0 [c]m'
    print(l3, units::cm);                               ///< '4.0 [c]m'
    // @note the unit base_quantity must be compatible with the base_quantity of the measurement


    // Using literal operators for units
    using namespace units::literals;
    auto l4 = 5.0m;                                     
    auto l5 = 6.0mm;                                    

    print(l4);                                          ///< '5.0 m'
    print(l5);                                          ///< '0.006 m'


    // Creating measurements by combining other measurements
    auto l6 = l1 + l2;                                  
    
    print(l6);                                          ///< '5.0 m'
    print(l1 * l2);                                     ///< '6 m^2'
    print("l1 / l2 = ", l1 / l2);                       ///< 'l1 / l2 = 0.666667'
    print<std::centi>("l1 / l2 = ", l1 / l2);           ///< 'l1 / l2 = 0.67'
    print<std::milli>("l1 / l2 = ", l1 / l2);           ///< 'l1 / l2 = 0.667'

```


#### A more concrete example
Consider an example, a little more complex, in which we want to plot the intensity of the diffraction pattern generated by a light beam, passing through a slit on a screen at a fixed distance, given by the integral function:

$$ I (x) = \int _{-\frac{d}{2}} ^{\frac{d}{2}} dx' cos(\frac{2\pi}{\lambda} \cdot (\sqrt{L^2 + (x - x')^2} - \sqrt{L^2 + x^2})) $$

where $d$ is the slit width, $\lambda$ is the wavelength of the light and $x$ is the distance from the center of the screen.

We can write the code in this way:
```cpp
#include "scipp"

using namespace scipp;

using namespace physics;            // for measurements 
using namespace units;              // for the units
using namespace units::literals;    // for the units literals

using namespace math; 
using namespace op;                 // for the operators and the functions
using namespace calculus;           // for the integral function and the interval struct

using tools::print;                 // for the print function


int main() {

    /// parameters of the experiment
    constexpr auto d = 10.0um;                          /// slit width
    constexpr auto lambda = 589.0nm;                    /// wavelength
    constexpr auto L = 0.5m;                            /// distance from the slit to the screen

    constexpr auto I_int = interval(-0.5 * d, 0.5 * d); /// interval of integration

    measurement<basis::length> x = -0.2m;                /// variable for the function I(x)
    constexpr auto I = interval(-0.2m, 0.2m);           /// interval of points where we want to evaluate I(x)
    constexpr auto dx = 1.0mm;                          /// distance between two points
    constexpr size_t N = I.steps(dx);                   /// numer of points with the math::calculus::interval function


    /// we define the integral function of I(x) as an std::function 
    /// we use a lambda function and we pass by value the parameters and by reference the integral variable
    /// the function is a scalar function, so it returns a measurement with basis::scalar
    std::function f = [lambda, L, &x](measurement<basis::length> t) -> measurement<basis::scalar> {   

        constexpr auto k = 2.0 * std::numbers::pi / lambda;     /// wave number
        return cos(k * (hypot(L, x - t) - hypot(L, x)));        /// using the math::op::hypot function     

    }; 


    print<micrometre>("d = ", d);                       /// we can specify the unit of measurement as a template parameter (type)
    print("lambda = ", lambda, nm);                     /// or we can specify the unit of measurement as a function parameter (value)
    print("interval of integration: ", I_int);          /// we can print the interval too
    print("f(0.0m) = ", f(0.0m));                       /// we can evaluate the function at a point


    std::vector<double> integral_values(N), x_values(N); /// to store the values for the plot

    /// we iterate over the interval using the meta::for_ function
    meta::for_<N>([&](auto i) { 

        /// we store the value of x, not the measurement
        x_values[i] = x.value; 

        /// we evaluate the integral using i.e. the midpoint rule from the math::calculus namespace
        /// the result of the integral is the width of the diffraction pattern
        /// the integration is correct from a dimensional point of view: the result is a measurement with basis::length
        /// the precision of the calculation could be specified using an std::ratio as a template parameter
        /// you can also just fix a number of steps as a function parameter or template parameter, as you prefer
        integral_values[i] = midpoint<std::micro>(f, I_int).value_as(um); /// we extract the value of the integral in micrometres

        /// we increment the x variable by dx
        x += dx; 

    });

    /// we plot the results using the matplotlib-cpp library
    plt::figure();
    plt::title("Diffracted intensity");
    plt::plot(x_values, integral_values);
    plt::xlabel("x [m]");  // we can specify the unit of measurement
    plt::ylabel("I [um]"); // we can specify the unit of measurement
    plt::grid(true);
    plt::tight_layout();
    plt::save("images/diffracted_intensity.png");
    plt::show();

    return 0; 

}
```

Here is the output of the program:
``` bash
d = 10 [u]m
lambda = 589 m
interval of integration: [ -5e-06 m, 5e-06 m ]
f(0.0m) = 1
```
![plot](../../images/diffracted_intensity.png)


### Benchmarks

The benchmarks are performed using the [Google Benchmark](https://github.com/google/benchmark) library and can be found in the `benchmark` folder from the root of the repository.
Here are the results of the benchmarks of the `scipp::math::op functions` on double and measurement, in comparison with the standard operators built-in in the C++ language:
``` bash
Run on (8 X 3400 MHz CPU s)
CPU Caches:
  L1 Data 32 KiB (x4)
  L1 Instruction 32 KiB (x4)
  L2 Unified 256 KiB (x4)
  L3 Unified 6144 KiB (x1)
Load Average: 0.74, 0.97, 1.12

Running ./build/benchmark/op/double
------------------------------------------------------
Benchmark            Time             CPU   Iterations
------------------------------------------------------
BM_Add           0.628 ns        0.628 ns   1000000000
BM_Multiply      0.628 ns        0.628 ns   1000000000
BM_Invert        0.628 ns        0.628 ns   1000000000
BM_Square        0.628 ns        0.628 ns   1000000000

Running ./build/benchmark/op/measurement
------------------------------------------------------
Benchmark            Time             CPU   Iterations
------------------------------------------------------
BM_Add           0.629 ns        0.629 ns   1000000000
BM_Multiply      0.629 ns        0.629 ns   1000000000
BM_Invert        0.628 ns        0.628 ns   1000000000
BM_Square        0.628 ns        0.628 ns   1000000000

Running ./build/benchmark/op/built_in
------------------------------------------------------
Benchmark            Time             CPU   Iterations
------------------------------------------------------
BM_Add           0.629 ns        0.629 ns   1000000000
BM_Multiply      0.629 ns        0.629 ns   1000000000
BM_Invert        0.629 ns        0.629 ns   1000000000
BM_Square        0.635 ns        0.635 ns   1000000000
